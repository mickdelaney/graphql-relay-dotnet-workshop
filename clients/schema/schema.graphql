"""
The `@defer` directive may be provided for fragment spreads and inline fragments
to inform the executor to delay the execution of the current fragment to
indicate deprioritization of the current fragment. A query with `@defer`
directive will cause the request to potentially return multiple responses, where
non-deferred data is delivered in the initial response and data deferred is
delivered in a subsequent response. `@include` and `@skip` take precedence over `@defer`.
"""
directive @defer(
  """
  If this argument label has a value other than null, it will be passed on to
  the result of this defer directive. This label is intended to give client
  applications a way to identify to which fragment a deferred result belongs to.
  """
  label: String

  """Deferred when true."""
  if: Boolean
) on FRAGMENT_SPREAD | INLINE_FRAGMENT

"""
The `@stream` directive may be provided for a field of `List` type so that the
backend can leverage technology such as asynchronous iterators to provide a
partial list in the initial response, and additional list items in subsequent
responses. `@include` and `@skip` take precedence over `@stream`.
"""
directive @stream(
  """
  If this argument label has a value other than null, it will be passed on to
  the result of this stream directive. This label is intended to give client
  applications a way to identify to which fragment a streamed result belongs to.
  """
  label: String

  """The initial elements that shall be send down to the consumer."""
  initialCount: Int!

  """Streamed when true."""
  if: Boolean!
) on FIELD

"""Delegates a resolver to a remote schema."""
directive @delegate(
  """The path to the field on the remote schema."""
  path: String

  """The name of the schema to which this field shall be delegated to."""
  schema: Name!
) on FIELD_DEFINITION

directive @computed(
  """Specifies the fields on which a computed field is dependent on."""
  dependantOn: [Name!]
) on FIELD_DEFINITION

"""Annotates the original name of a type."""
directive @source(
  """The original name of the annotated type."""
  name: Name!

  """The name of the schema to which this type belongs to."""
  schema: Name!
) on ENUM | OBJECT | INTERFACE | UNION | INPUT_OBJECT | FIELD_DEFINITION | INPUT_FIELD_DEFINITION | ARGUMENT_DEFINITION | ENUM_VALUE

input AddPersonInput {
  clientMutationId: String!
  name: String!
  webSite: String
}

type AddPersonPayload {
  clientMutationId: String!
  person: EdgeOfPerson!
}

type ContentItem {
  id: Int!
  ownerId: Int!
  name: String!
}

type EdgeOfPerson {
  node: Person!
  cursor: String!
}

type Mutation {
  addPerson(input: AddPersonInput!): AddPersonPayload!
}

"""
The name scalar represents a valid GraphQL name as specified in the spec and can be used to refer to fields or types.
"""
scalar Name

"""
The node interface is implemented by entities that have a global unique identifier.
"""
interface Node {
  id: ID!
}

"""Information about pagination in a connection."""
type PageInfo {
  """
  Indicates whether more edges exist following the set defined by the clients arguments.
  """
  hasNextPage: Boolean!

  """
  Indicates whether more edges exist prior the set defined by the clients arguments.
  """
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: String

  """When paginating forwards, the cursor to continue."""
  endCursor: String
}

type Person implements Node {
  id: ID!
  name: String
  webSite: String
}

"""A connection to a list of items."""
type PersonConnection {
  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """A list of edges."""
  edges: [PersonEdge!]

  """A flattened list of the nodes."""
  nodes: [Person!]
}

"""An edge in a connection."""
type PersonEdge {
  """A cursor for use in pagination."""
  cursor: String!

  """The item at the end of the edge."""
  node: Person!
}

type Query {
  node(id: ID!): Node
  people(first: Int, after: String, last: Int, before: String): PersonConnection
  personById(id: ID!): Person!
  contentItem: ContentItem!
}

